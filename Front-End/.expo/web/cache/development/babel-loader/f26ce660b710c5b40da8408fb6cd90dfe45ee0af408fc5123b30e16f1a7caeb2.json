{"ast":null,"code":"import { EventEmitter, CodedError, UnavailabilityError } from 'expo-modules-core';\nimport NotificationsHandlerModule from './NotificationsHandlerModule';\nexport class NotificationTimeoutError extends CodedError {\n  constructor(notificationId, notification) {\n    super('ERR_NOTIFICATION_TIMEOUT', `Notification handling timed out for ID ${notificationId}.`);\n    this.info = {\n      id: notificationId,\n      notification\n    };\n  }\n}\nconst notificationEmitter = new EventEmitter(NotificationsHandlerModule);\nconst handleNotificationEventName = 'onHandleNotification';\nconst handleNotificationTimeoutEventName = 'onHandleNotificationTimeout';\nlet handleSubscription = null;\nlet handleTimeoutSubscription = null;\nexport function setNotificationHandler(handler) {\n  if (handleSubscription) {\n    handleSubscription.remove();\n    handleSubscription = null;\n  }\n  if (handleTimeoutSubscription) {\n    handleTimeoutSubscription.remove();\n    handleTimeoutSubscription = null;\n  }\n  if (handler) {\n    handleSubscription = notificationEmitter.addListener(handleNotificationEventName, async ({\n      id,\n      notification\n    }) => {\n      if (!NotificationsHandlerModule.handleNotificationAsync) {\n        handler.handleError?.(id, new UnavailabilityError('Notifications', 'handleNotificationAsync'));\n        return;\n      }\n      try {\n        const behavior = await handler.handleNotification(notification);\n        await NotificationsHandlerModule.handleNotificationAsync(id, behavior);\n        handler.handleSuccess?.(id);\n      } catch (error) {\n        handler.handleError?.(id, error);\n      }\n    });\n    handleTimeoutSubscription = notificationEmitter.addListener(handleNotificationTimeoutEventName, ({\n      id,\n      notification\n    }) => handler.handleError?.(id, new NotificationTimeoutError(id, notification)));\n  }\n}","map":{"version":3,"names":["EventEmitter","CodedError","UnavailabilityError","NotificationsHandlerModule","NotificationTimeoutError","constructor","notificationId","notification","info","id","notificationEmitter","handleNotificationEventName","handleNotificationTimeoutEventName","handleSubscription","handleTimeoutSubscription","setNotificationHandler","handler","remove","addListener","handleNotificationAsync","handleError","behavior","handleNotification","handleSuccess","error"],"sources":["C:\\Users\\eusou\\Desktop\\DVGC Mobile\\Front End\\node_modules\\expo-notifications\\src\\NotificationsHandler.ts"],"sourcesContent":["import { EventEmitter, Subscription, CodedError, UnavailabilityError } from 'expo-modules-core';\n\nimport { Notification, NotificationBehavior } from './Notifications.types';\nimport NotificationsHandlerModule from './NotificationsHandlerModule';\n\n/**\n * @hidden\n */\nexport class NotificationTimeoutError extends CodedError {\n  info: { notification: Notification; id: string };\n  constructor(notificationId: string, notification: Notification) {\n    super('ERR_NOTIFICATION_TIMEOUT', `Notification handling timed out for ID ${notificationId}.`);\n    this.info = { id: notificationId, notification };\n  }\n}\n\n// @docsMissing\nexport type NotificationHandlingError = NotificationTimeoutError | Error;\n\nexport interface NotificationHandler {\n  /**\n   * A function accepting an incoming notification returning a `Promise` resolving to a behavior ([`NotificationBehavior`](#notificationbehavior))\n   * applicable to the notification\n   * @param notification An object representing the notification.\n   */\n  handleNotification: (notification: Notification) => Promise<NotificationBehavior>;\n  /**\n   * A function called whenever an incoming notification is handled successfully.\n   * @param notificationId Identifier of the notification.\n   */\n  handleSuccess?: (notificationId: string) => void;\n  /**\n   * A function called whenever handling of an incoming notification fails.\n   * @param notificationId Identifier of the notification.\n   * @param error An error which occurred in form of `NotificationHandlingError` object.\n   */\n  handleError?: (notificationId: string, error: NotificationHandlingError) => void;\n}\n\ntype HandleNotificationEvent = {\n  id: string;\n  notification: Notification;\n};\n\ntype HandleNotificationTimeoutEvent = HandleNotificationEvent;\n\n// Web uses SyntheticEventEmitter\nconst notificationEmitter = new EventEmitter(NotificationsHandlerModule);\n\nconst handleNotificationEventName = 'onHandleNotification';\nconst handleNotificationTimeoutEventName = 'onHandleNotificationTimeout';\n\nlet handleSubscription: Subscription | null = null;\nlet handleTimeoutSubscription: Subscription | null = null;\n\n/**\n * When a notification is received while the app is running, using this function you can set a callback that will decide\n * whether the notification should be shown to the user or not.\n *\n * When a notification is received, `handleNotification` is called with the incoming notification as an argument.\n * The function should respond with a behavior object within 3 seconds, otherwise, the notification will be discarded.\n * If the notification is handled successfully, `handleSuccess` is called with the identifier of the notification,\n * otherwise (or on timeout) `handleError` will be called.\n *\n * The default behavior when the handler is not set or does not respond in time is not to show the notification.\n * @param handler A single parameter which should be either `null` (if you want to clear the handler) or a [`NotificationHandler`](#notificationhandler) object.\n *\n * @example Implementing a notification handler that always shows the notification when it is received.\n * ```jsx\n * import * as Notifications from 'expo-notifications';\n *\n * Notifications.setNotificationHandler({\n *   handleNotification: async () => ({\n *     shouldShowAlert: true,\n *     shouldPlaySound: false,\n *     shouldSetBadge: false,\n *   }),\n * });\n * ```\n * @header inForeground\n */\nexport function setNotificationHandler(handler: NotificationHandler | null): void {\n  if (handleSubscription) {\n    handleSubscription.remove();\n    handleSubscription = null;\n  }\n  if (handleTimeoutSubscription) {\n    handleTimeoutSubscription.remove();\n    handleTimeoutSubscription = null;\n  }\n\n  if (handler) {\n    handleSubscription = notificationEmitter.addListener<HandleNotificationEvent>(\n      handleNotificationEventName,\n      async ({ id, notification }) => {\n        if (!NotificationsHandlerModule.handleNotificationAsync) {\n          handler.handleError?.(\n            id,\n            new UnavailabilityError('Notifications', 'handleNotificationAsync')\n          );\n          return;\n        }\n\n        try {\n          const behavior = await handler.handleNotification(notification);\n          await NotificationsHandlerModule.handleNotificationAsync(id, behavior);\n          handler.handleSuccess?.(id);\n        } catch (error) {\n          handler.handleError?.(id, error);\n        }\n      }\n    );\n\n    handleTimeoutSubscription = notificationEmitter.addListener<HandleNotificationTimeoutEvent>(\n      handleNotificationTimeoutEventName,\n      ({ id, notification }) =>\n        handler.handleError?.(id, new NotificationTimeoutError(id, notification))\n    );\n  }\n}\n"],"mappings":"AAAA,SAASA,YAAY,EAAgBC,UAAU,EAAEC,mBAAmB,QAAQ,mBAAmB;AAG/F,OAAOC,0BAA0B,MAAM,8BAA8B;AAKrE,OAAM,MAAOC,wBAAyB,SAAQH,UAAU;EAEtDI,YAAYC,cAAsB,EAAEC,YAA0B;IAC5D,KAAK,CAAC,0BAA0B,EAAE,0CAA0CD,cAAc,GAAG,CAAC;IAC9F,IAAI,CAACE,IAAI,GAAG;MAAEC,EAAE,EAAEH,cAAc;MAAEC;IAAY,CAAE;EAClD;;AAkCF,MAAMG,mBAAmB,GAAG,IAAIV,YAAY,CAACG,0BAA0B,CAAC;AAExE,MAAMQ,2BAA2B,GAAG,sBAAsB;AAC1D,MAAMC,kCAAkC,GAAG,6BAA6B;AAExE,IAAIC,kBAAkB,GAAwB,IAAI;AAClD,IAAIC,yBAAyB,GAAwB,IAAI;AA4BzD,OAAM,SAAUC,sBAAsBA,CAACC,OAAmC;EACxE,IAAIH,kBAAkB,EAAE;IACtBA,kBAAkB,CAACI,MAAM,EAAE;IAC3BJ,kBAAkB,GAAG,IAAI;;EAE3B,IAAIC,yBAAyB,EAAE;IAC7BA,yBAAyB,CAACG,MAAM,EAAE;IAClCH,yBAAyB,GAAG,IAAI;;EAGlC,IAAIE,OAAO,EAAE;IACXH,kBAAkB,GAAGH,mBAAmB,CAACQ,WAAW,CAClDP,2BAA2B,EAC3B,OAAO;MAAEF,EAAE;MAAEF;IAAY,CAAE,KAAI;MAC7B,IAAI,CAACJ,0BAA0B,CAACgB,uBAAuB,EAAE;QACvDH,OAAO,CAACI,WAAW,GACjBX,EAAE,EACF,IAAIP,mBAAmB,CAAC,eAAe,EAAE,yBAAyB,CAAC,CACpE;QACD;;MAGF,IAAI;QACF,MAAMmB,QAAQ,GAAG,MAAML,OAAO,CAACM,kBAAkB,CAACf,YAAY,CAAC;QAC/D,MAAMJ,0BAA0B,CAACgB,uBAAuB,CAACV,EAAE,EAAEY,QAAQ,CAAC;QACtEL,OAAO,CAACO,aAAa,GAAGd,EAAE,CAAC;OAC5B,CAAC,OAAOe,KAAK,EAAE;QACdR,OAAO,CAACI,WAAW,GAAGX,EAAE,EAAEe,KAAK,CAAC;;IAEpC,CAAC,CACF;IAEDV,yBAAyB,GAAGJ,mBAAmB,CAACQ,WAAW,CACzDN,kCAAkC,EAClC,CAAC;MAAEH,EAAE;MAAEF;IAAY,CAAE,KACnBS,OAAO,CAACI,WAAW,GAAGX,EAAE,EAAE,IAAIL,wBAAwB,CAACK,EAAE,EAAEF,YAAY,CAAC,CAAC,CAC5E;;AAEL","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}