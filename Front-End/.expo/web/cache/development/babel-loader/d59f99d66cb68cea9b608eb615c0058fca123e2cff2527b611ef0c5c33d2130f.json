{"ast":null,"code":"import * as Application from 'expo-application';\nimport Constants from 'expo-constants';\nimport { Platform, CodedError, UnavailabilityError } from 'expo-modules-core';\nimport { setAutoServerRegistrationEnabledAsync } from './DevicePushTokenAutoRegistration.fx';\nimport ServerRegistrationModule from './ServerRegistrationModule';\nimport getDevicePushTokenAsync from './getDevicePushTokenAsync';\nconst productionBaseUrl = 'https://exp.host/--/api/v2/';\nexport default async function getExpoPushTokenAsync(options = {}) {\n  const devicePushToken = options.devicePushToken || (await getDevicePushTokenAsync());\n  const deviceId = options.deviceId || (await getDeviceIdAsync());\n  const projectId = options.projectId || Constants.easConfig?.projectId;\n  if (!projectId) {\n    console.warn('Calling getExpoPushTokenAsync without specifying a projectId is deprecated and will no longer be supported in SDK 49+');\n  }\n  if (!projectId) {\n    throw new CodedError('ERR_NOTIFICATIONS_NO_EXPERIENCE_ID', \"No 'projectId' found. If 'projectId' can't be inferred from the manifest (eg. in bare workflow), you have to pass it in yourself.\");\n  }\n  const applicationId = options.applicationId || Application.applicationId;\n  if (!applicationId) {\n    throw new CodedError('ERR_NOTIFICATIONS_NO_APPLICATION_ID', \"No applicationId found. If it can't be inferred from native configuration by expo-application, you have to pass it in yourself.\");\n  }\n  const type = options.type || getTypeOfToken(devicePushToken);\n  const development = options.development || (await shouldUseDevelopmentNotificationService());\n  const baseUrl = options.baseUrl ?? productionBaseUrl;\n  const url = options.url ?? `${baseUrl}push/getExpoPushToken`;\n  const body = {\n    type,\n    deviceId: deviceId.toLowerCase(),\n    development,\n    appId: applicationId,\n    deviceToken: getDeviceToken(devicePushToken),\n    projectId\n  };\n  const response = await fetch(url, {\n    method: 'POST',\n    headers: {\n      'content-type': 'application/json'\n    },\n    body: JSON.stringify(body)\n  }).catch(error => {\n    throw new CodedError('ERR_NOTIFICATIONS_NETWORK_ERROR', `Error encountered while fetching Expo token: ${error}.`);\n  });\n  if (!response.ok) {\n    const statusInfo = response.statusText || response.status;\n    let body = undefined;\n    try {\n      body = await response.text();\n    } catch {}\n    throw new CodedError('ERR_NOTIFICATIONS_SERVER_ERROR', `Error encountered while fetching Expo token, expected an OK response, received: ${statusInfo} (body: \"${body}\").`);\n  }\n  const expoPushToken = getExpoPushToken(await parseResponse(response));\n  try {\n    if (options.url || options.baseUrl) {\n      console.debug(`[expo-notifications] Since the URL endpoint to register in has been customized in the options, expo-notifications won't try to auto-update the device push token on the server.`);\n    } else {\n      await setAutoServerRegistrationEnabledAsync(true);\n    }\n  } catch (e) {\n    console.warn('[expo-notifications] Could not enable automatically registering new device tokens with the Expo notification service', e);\n  }\n  return {\n    type: 'expo',\n    data: expoPushToken\n  };\n}\nasync function parseResponse(response) {\n  try {\n    return await response.json();\n  } catch {\n    try {\n      throw new CodedError('ERR_NOTIFICATIONS_SERVER_ERROR', `Expected a JSON response from server when fetching Expo token, received body: ${JSON.stringify(await response.text())}.`);\n    } catch {\n      throw new CodedError('ERR_NOTIFICATIONS_SERVER_ERROR', `Expected a JSON response from server when fetching Expo token, received response: ${JSON.stringify(response)}.`);\n    }\n  }\n}\nfunction getExpoPushToken(data) {\n  if (!data || !(typeof data === 'object') || !data.data || !(typeof data.data === 'object') || !data.data.expoPushToken || !(typeof data.data.expoPushToken === 'string')) {\n    throw new CodedError('ERR_NOTIFICATIONS_SERVER_ERROR', `Malformed response from server, expected \"{ data: { expoPushToken: string } }\", received: ${JSON.stringify(data, null, 2)}.`);\n  }\n  return data.data.expoPushToken;\n}\nasync function getDeviceIdAsync() {\n  try {\n    if (!ServerRegistrationModule.getInstallationIdAsync) {\n      throw new UnavailabilityError('ExpoServerRegistrationModule', 'getInstallationIdAsync');\n    }\n    return await ServerRegistrationModule.getInstallationIdAsync();\n  } catch (e) {\n    throw new CodedError('ERR_NOTIF_DEVICE_ID', `Could not have fetched installation ID of the application: ${e}.`);\n  }\n}\nfunction getDeviceToken(devicePushToken) {\n  if (typeof devicePushToken.data === 'string') {\n    return devicePushToken.data;\n  }\n  return JSON.stringify(devicePushToken.data);\n}\nasync function shouldUseDevelopmentNotificationService() {\n  if (Platform.OS === 'ios') {\n    try {\n      const notificationServiceEnvironment = await Application.getIosPushNotificationServiceEnvironmentAsync();\n      if (notificationServiceEnvironment === 'development') {\n        return true;\n      }\n    } catch {}\n  }\n  return false;\n}\nfunction getTypeOfToken(devicePushToken) {\n  switch (devicePushToken.type) {\n    case 'ios':\n      return 'apns';\n    case 'android':\n      return 'fcm';\n    default:\n      return devicePushToken.type;\n  }\n}","map":{"version":3,"names":["Application","Constants","Platform","CodedError","UnavailabilityError","setAutoServerRegistrationEnabledAsync","ServerRegistrationModule","getDevicePushTokenAsync","productionBaseUrl","getExpoPushTokenAsync","options","devicePushToken","deviceId","getDeviceIdAsync","projectId","easConfig","console","warn","applicationId","type","getTypeOfToken","development","shouldUseDevelopmentNotificationService","baseUrl","url","body","toLowerCase","appId","deviceToken","getDeviceToken","response","fetch","method","headers","JSON","stringify","catch","error","ok","statusInfo","statusText","status","undefined","text","expoPushToken","getExpoPushToken","parseResponse","debug","e","data","json","getInstallationIdAsync","OS","notificationServiceEnvironment","getIosPushNotificationServiceEnvironmentAsync"],"sources":["C:\\Users\\eusou\\Desktop\\DVGC Mobile\\Front End\\node_modules\\expo-notifications\\src\\getExpoPushTokenAsync.ts"],"sourcesContent":["import * as Application from 'expo-application';\nimport Constants from 'expo-constants';\nimport { Platform, CodedError, UnavailabilityError } from 'expo-modules-core';\n\nimport { setAutoServerRegistrationEnabledAsync } from './DevicePushTokenAutoRegistration.fx';\nimport ServerRegistrationModule from './ServerRegistrationModule';\nimport { DevicePushToken, ExpoPushToken, ExpoPushTokenOptions } from './Tokens.types';\nimport getDevicePushTokenAsync from './getDevicePushTokenAsync';\n\nconst productionBaseUrl = 'https://exp.host/--/api/v2/';\n\n/**\n * Returns an Expo token that can be used to send a push notification to the device using Expo's push notifications service.\n *\n * This method makes requests to the Expo's servers. It can get rejected in cases where the request itself fails\n * (for example, due to the device being offline, experiencing a network timeout, or other HTTPS request failures).\n * To provide offline support to your users, you should `try/catch` this method and implement retry logic to attempt\n * to get the push token later, once the device is back online.\n *\n * > For Expo's backend to be able to send notifications to your app, you will need to provide it with push notification keys.\n * For more information, see [credentials](/push-notifications/push-notifications-setup/#get-credentials-for-development-builds) in the push notifications setup.\n *\n * @param options Object allowing you to pass in push notification configuration.\n * @return Returns a `Promise` that resolves to an object representing acquired push token.\n * @header fetch\n *\n * @example\n * ```ts\n * import * as Notifications from 'expo-notifications';\n *\n * export async function registerForPushNotificationsAsync(userId: string) {\n *   const expoPushToken = await Notifications.getExpoPushTokenAsync({\n *    projectId: 'your-project-id',\n *   });\n *\n *   await fetch('https://example.com/', {\n *     method: 'POST',\n *     headers: {\n *       'Content-Type': 'application/json',\n *     },\n *     body: JSON.stringify({\n *       userId,\n *       expoPushToken,\n *     }),\n *   });\n * }\n * ```\n */\nexport default async function getExpoPushTokenAsync(\n  options: ExpoPushTokenOptions = {}\n): Promise<ExpoPushToken> {\n  const devicePushToken = options.devicePushToken || (await getDevicePushTokenAsync());\n\n  const deviceId = options.deviceId || (await getDeviceIdAsync());\n  const projectId = options.projectId || Constants.easConfig?.projectId;\n\n  if (!projectId) {\n    console.warn(\n      'Calling getExpoPushTokenAsync without specifying a projectId is deprecated and will no longer be supported in SDK 49+'\n    );\n  }\n\n  if (!projectId) {\n    throw new CodedError(\n      'ERR_NOTIFICATIONS_NO_EXPERIENCE_ID',\n      \"No 'projectId' found. If 'projectId' can't be inferred from the manifest (eg. in bare workflow), you have to pass it in yourself.\"\n    );\n  }\n\n  const applicationId = options.applicationId || Application.applicationId;\n  if (!applicationId) {\n    throw new CodedError(\n      'ERR_NOTIFICATIONS_NO_APPLICATION_ID',\n      \"No applicationId found. If it can't be inferred from native configuration by expo-application, you have to pass it in yourself.\"\n    );\n  }\n  const type = options.type || getTypeOfToken(devicePushToken);\n  const development = options.development || (await shouldUseDevelopmentNotificationService());\n\n  const baseUrl = options.baseUrl ?? productionBaseUrl;\n  const url = options.url ?? `${baseUrl}push/getExpoPushToken`;\n\n  const body = {\n    type,\n    deviceId: deviceId.toLowerCase(),\n    development,\n    appId: applicationId,\n    deviceToken: getDeviceToken(devicePushToken),\n    projectId,\n  };\n\n  const response = await fetch(url, {\n    method: 'POST',\n    headers: {\n      'content-type': 'application/json',\n    },\n    body: JSON.stringify(body),\n  }).catch((error) => {\n    throw new CodedError(\n      'ERR_NOTIFICATIONS_NETWORK_ERROR',\n      `Error encountered while fetching Expo token: ${error}.`\n    );\n  });\n\n  if (!response.ok) {\n    const statusInfo = response.statusText || response.status;\n    let body: string | undefined = undefined;\n    try {\n      body = await response.text();\n    } catch {\n      // do nothing\n    }\n    throw new CodedError(\n      'ERR_NOTIFICATIONS_SERVER_ERROR',\n      `Error encountered while fetching Expo token, expected an OK response, received: ${statusInfo} (body: \"${body}\").`\n    );\n  }\n\n  const expoPushToken = getExpoPushToken(await parseResponse(response));\n\n  try {\n    if (options.url || options.baseUrl) {\n      console.debug(\n        `[expo-notifications] Since the URL endpoint to register in has been customized in the options, expo-notifications won't try to auto-update the device push token on the server.`\n      );\n    } else {\n      await setAutoServerRegistrationEnabledAsync(true);\n    }\n  } catch (e) {\n    console.warn(\n      '[expo-notifications] Could not enable automatically registering new device tokens with the Expo notification service',\n      e\n    );\n  }\n\n  return {\n    type: 'expo',\n    data: expoPushToken,\n  };\n}\n\nasync function parseResponse(response: Response) {\n  try {\n    return await response.json();\n  } catch {\n    try {\n      throw new CodedError(\n        'ERR_NOTIFICATIONS_SERVER_ERROR',\n        `Expected a JSON response from server when fetching Expo token, received body: ${JSON.stringify(\n          await response.text()\n        )}.`\n      );\n    } catch {\n      throw new CodedError(\n        'ERR_NOTIFICATIONS_SERVER_ERROR',\n        `Expected a JSON response from server when fetching Expo token, received response: ${JSON.stringify(\n          response\n        )}.`\n      );\n    }\n  }\n}\n\nfunction getExpoPushToken(data: any) {\n  if (\n    !data ||\n    !(typeof data === 'object') ||\n    !data.data ||\n    !(typeof data.data === 'object') ||\n    !data.data.expoPushToken ||\n    !(typeof data.data.expoPushToken === 'string')\n  ) {\n    throw new CodedError(\n      'ERR_NOTIFICATIONS_SERVER_ERROR',\n      `Malformed response from server, expected \"{ data: { expoPushToken: string } }\", received: ${JSON.stringify(\n        data,\n        null,\n        2\n      )}.`\n    );\n  }\n\n  return data.data.expoPushToken as string;\n}\n\n// Same as in DevicePushTokenAutoRegistration\nasync function getDeviceIdAsync() {\n  try {\n    if (!ServerRegistrationModule.getInstallationIdAsync) {\n      throw new UnavailabilityError('ExpoServerRegistrationModule', 'getInstallationIdAsync');\n    }\n\n    return await ServerRegistrationModule.getInstallationIdAsync();\n  } catch (e) {\n    throw new CodedError(\n      'ERR_NOTIF_DEVICE_ID',\n      `Could not have fetched installation ID of the application: ${e}.`\n    );\n  }\n}\n\nfunction getDeviceToken(devicePushToken: DevicePushToken) {\n  if (typeof devicePushToken.data === 'string') {\n    return devicePushToken.data;\n  }\n\n  return JSON.stringify(devicePushToken.data);\n}\n\n// Same as in DevicePushTokenAutoRegistration\nasync function shouldUseDevelopmentNotificationService() {\n  if (Platform.OS === 'ios') {\n    try {\n      const notificationServiceEnvironment =\n        await Application.getIosPushNotificationServiceEnvironmentAsync();\n      if (notificationServiceEnvironment === 'development') {\n        return true;\n      }\n    } catch {\n      // We can't do anything here, we'll fallback to false then.\n    }\n  }\n\n  return false;\n}\n\n// Same as in DevicePushTokenAutoRegistration\nfunction getTypeOfToken(devicePushToken: DevicePushToken) {\n  switch (devicePushToken.type) {\n    case 'ios':\n      return 'apns';\n    case 'android':\n      return 'fcm';\n    // This probably will error on server, but let's make this function future-safe.\n    default:\n      return devicePushToken.type;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}